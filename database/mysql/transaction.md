# 事务

一个事务是一个完整的业务逻辑单元，不能再分，要么全部执行成功，要么全部失败。

## ✏ 1、事务的四大特性（ACID）

1. 原子性（`Atomicity`）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
2. 一致性（`Consistency`）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
3. 隔离性（`Isolation`）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
4. 持久性（`Durability`）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

## ✏ 2、事务并发带来的问题

多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致一下的问题：

1. 脏读（`Dirty read`）：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
2. 丢失修改（`Lost to modify`）：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
3. 不可重复读（`Unrepeatable read`）：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
4. 幻读（`Phantom read`）：幻读与不可重复读类似。它发生在一个事务（`T1`）读取了几行数据，接着另一个并发事务（`T2`）插入了一些数据时。在随后的查询中，第一个事务（`T1`）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**不可重复读和幻读区别：**

不可重复读的重点是修改，幻读的重点在于新增或者删除。 **解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。**

例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。

例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。

## ✏ 3、事务的隔离级别

**SQL 标准定义了四个隔离级别：**

### 🖋 3.1、Read uncommitted\(读未提交\) 

如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据，该隔离级别可以通过“排他写锁”，但是不排斥读线程实现。这样就避免了更新丢失，却可能出现脏读，也就是说事务B读取到了事务A未提交的数据。

解决了更新丢失，但还是可能会出现脏读

### 🖋 3.2、Read committed\(读提交\) 

如果是一个读事务\(线程\)，则允许其他事务读写，如果是写事务将会禁止其他事务访问该行数据，该隔离级别避免了脏读，但是可能出现不可重复读。事务A事先读取了数据，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。

解决了更新丢失和脏读问题

### 🖋 3.3、Repeatable read\(可重复读取\) 

可重复读取是指在一个事务内，多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据\(包括了读写\)，这样就可以在同一个事务内两次读到的数据是一样的，因此称为是可重复读隔离级别，读取数据的事务将会禁止写事务\(但允许读事务\)，写事务则禁止任何其他事务\(包括了读写\)，这样避免了不可重复读和脏读，但是有时可能会出现幻读。\(读取数据的事务\)可以通过“共享读镜”和“排他写锁”实现。

解决了更新丢失、脏读、不可重复读、但是还会出现幻读

### 🖋 3.4、Serializable\(可序化\) 

提供严格的事务隔离，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行，如果仅仅通过“行级锁”是无法实现序列化的，必须通过其他机制保证新插入的数据不会被执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也是最高的，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读。

解决了更新丢失、脏读、不可重复读、幻读\(虚读\)

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :--- | :---: | :---: | :---: |
| 读未提交（read-uncommitted） | 是 | 是 | 是 |
| 读提交（read-committed） | 否 | 是 | 是 |
| 可重复读（repeatable-read） | 否 | 否 | 是 |
| 串行化（serializable） | 否 | 否 | 否 |

以上四种隔离级别最高的是`Serializable`级别，最低的是`Read uncommitted`级别，当然级别越高，执行效率就越低，像`Serializeble`这样的级别，就是以锁表的方式\(类似于Java多线程中的锁\)使得其他线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况决定。在`MySQL`数据库中，支持上面四种隔离级别，默认的为`Repeatable read`\(可重复读\)；而在`Oracle`数据库中，只支持`Serializeble`\(串行化\)级别和`Read committed`\(读已提交\)这两种级别，其中默认的为`Read committed`级别。

### 🖋 3.5、查看和设置隔离级别

```sql
SELECT @@tx_isolation;  

set transaction isolation level 隔离级别名称;
set tx_isolation='隔离级别名称';
```

设置数据库的隔离级别一定要是在开启事务之前。隔离级别的设置只对当前连接有效，对于使用`MySQL`命令窗口而言，一个窗口就相当于一个连接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于`JDBC`操作数据库来说，一个`Connection`对象相当与一个连接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他连接Connection对象无关。

