# Linux进程间通信

![](../../.gitbook/assets/10%20%283%29.jpg)

每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。

![](../../.gitbook/assets/20.png)

## ✏ 1、管道

Linux 管道使用竖线`|`连接多个命令，这被称为管道符。如：

```bash
$ ps auxf | grep mysql 
```

它的功能是将前一个命令（`ps auxf`）的输出，作为后一个命令（`grep mysql`）的输入，从这功能描述，可以看出**管道传输数据是单向的。**并且上面这种管道是没有名字的，所以`|`表示的管道称为匿名管道，用完了就销毁。

管道还有另外一个类型是命名管道，也被叫做 FIFO，因为数据是先进先出的传输方式。在使用命名管道前，先需要通过 `mkfifo` 命令来创建，并且指定管道名字：

```bash
$ mkfifo myPipe
```

myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：

```bash
$ ls -l
prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe
```

接下来，我们往 myPipe 这个管道写入数据：

```bash
$ echo "hello" > myPipe // 将数据写进管道 
                        // 停住了 ... 
```

操作完成后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。于是，我们执行另外一个命令来读取这个管道里的数据：

```bash
$ cat < myPipe // 读取管道里的数据 
hello
```

可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。可以看出，**管道这种通信方式效率低，不适合进程间频繁地交换数据**。

### 🖊 1.1、无名管道的原理

匿名管道的创建，需要通过下面这个系统调用：

```c
int pipe(int fd[2])
```

这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 `fd[0]`，另一个是管道的写入端描述符 `fd[1]`。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。

其实，所谓的管道，就是内核里面的一串缓存。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。

在 shell 里面执行 `A | B`命令的时候，A 进程和 B 进程都是 shell 使用 fork 创建的子进程，两个进程各有 `fd[0]` 与 `fd[1]` ，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。

![](../../.gitbook/assets/97.png)

所以说，在 shell 里通过「`|`」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。

无名管道存在着如下两个严重的缺点：

* 第一，无名管道只能用于连接具有共同祖先的进程。
* 第二，无名管道是依附进程而临时存在的。

### 🖊 1.2、有名管道的原理

**对于匿名管道，它的通信范围是存在父子关系的进程**。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。另外，**对于命名管道，它可以在不相关的进程间也能相互通信**。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。

不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 `lseek` 之类的文件定位操作。

## ✏ 2、消息队列

前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。对于这个问题，**消息队列**的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。

 **消息队列是保存在内核中的消息链表**，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。

消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。

消息队列这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。但邮件的通信方式存在不足的地方有两点，**一是通信不及时，二是附件也有大小限制**，这同样也是消息队列通信不足的点。

**消息队列不适合比较大数据的传输**，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 `MSGMAX` 和 `MSGMNB`，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。

**消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。

## ✏ 3、共享内存

消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那**共享内存**的方式，就很好的解决了这一问题。

现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。

**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。

![](../../.gitbook/assets/96.png)

共享内存没有任何的同步与互斥机制，所以要使用信号量来实现对共享内存的存取的同步。

### 🖊 3.1、相关函数

#### 🍊 1、创建共享内存：`shmget()` 函数

```c
int shmget(key_t key, size_t size, int shmflg);  // 成功返回共享内存的ID,出错返回-1  
```

* 第一个参数 key 是长整型（唯一非零），系统建立 IPC 通讯 （ 消息队列、 信号量和 共享内存） 时必须指定一个ID值。通常情况下，该 id 值通过 `ftok` 函数得到，由内核变成标识符，要想让两个进程看到同一个信号集，只需设置 key 值不变就可以。
* 第二个参数 size 指定共享内存的大小，它的值一般为一页大小的整数倍（未到一页，操作系统向上对齐到一页，但是用户实际能使用只有自己所申请的大小）。
* 第三个参数 `shmflg` 是一组标志，创建一个新的共享内存，将 `shmflg` 设置了 `IPC_CREAT` 标志后，共享内存存在就打开。而`IPC_CREAT | IPC_EXCL`则可以创建一个新的，唯一的共享内存，如果共享内存已存在，返回一个错误。一般我们还会 “或” 上一个文件权限。

#### 🍊 2、操作共享内存：`shmctl()` 函数

```c
int shmctl(int shm_id, int cmd, struct shmid_ds *buf);  // 成功返回0，出错返回-1
```

* 第一个参数，shm\_id 是 shmget 函数返回的共享内存标识符。
* 第二个参数，cmd 是要采取的操作，它可以取下面的三个值 ：
* 1. `IPC_STAT`：把 shmid\_ds 结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖 shmid\_ds 的值。
  2. `IPC_SET`：如果进程有足够的权限，就把共享内存的当前关联值设置为 shmid\_ds 结构中给出的值。
  3. `IPC_RMID`：删除共享内存段。
* 第三个参数，buf 是一个结构指针，它指向共享内存模式和访问权限的结构。 shmid\_ds 结构至少包括以下成员：

```cpp
struct shmid_ds 
{ 
    uid_t shm_perm.uid; 
    uid_t shm_perm.gid; 
    mode_t shm_perm.mode; 
};
```

#### 🍊 3、挂接操作：`shmat()` 函数

```cpp
void *shmat(int shm_id, const void *shm_addr, int shmflg); // 成功返回指向共享存储段的指针，出错返回-1　
```

创建共享存储段之后，将进程连接到它的地址空间。

* 第一个参数，shm\_id 是由 shmget 函数返回的共享内存标识。
* 第二个参数，shm\_addr 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。
* 第三个参数，shm\_flg 是一组标志位，通常为0。

#### 🍊 4、分离操作：`shmdt()` 函数

```cpp
int shmdt(const void *shmaddr); // 成功返回0，出错返回-1
```

该操作不从系统中删除标识符和其数据结构，要显示调用 `shmctl`\(带命令`IPC_RMID`\) 才能删除它。

* addr 参数是以前调用 shmat 时的返回值。

## ✏ 4、信号量

用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。

为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，**信号量**就实现了这一保护机制。

**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**。

信号量表示资源的数量，控制信号量的方式有两种原子操作：

* 一个是 **P 操作**，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。
* 另一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；

P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。

### 🖊 4.1、互斥信号量

 如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 `1`。

具体的过程如下：

* 进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。
* 若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。
* 直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。

可以发现，信号初始化为 `1`，就代表着是**互斥信号量**，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。

### 🖊 4.2、同步信号量

在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。

例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。

那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 `0`。

具体过程：

* 如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；
* 接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；
* 最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。

可以发现，信号初始化为 `0`，就代表着是**同步信号量**，它可以保证进程 A 应在进程 B 之前执行。

## ✏ 5、信号

## ✏ 6、Socket

