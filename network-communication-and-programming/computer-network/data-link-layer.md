# 数据链路层

数据链路层 在物理层所提供的服务的基础上 向网络层提供服务，即将原始的、有差错的物理线路改进成为逻辑上无差错的数据链路，从而向网络层提供高质量的服务。它一般包括 3 种基本服务：无确定的无连接服务、有确定的有连接服务、有确定的无连接服务（不存在无确定的有连接服务）。

## ✏ 1、主要功能

数据链路层的主要功能如下： 

1. 链路管理：负责数据链路的建立、维持和释放，主要用于面向连接服务。 
2. 帧同步：接收方确定收到的比特流中一帧的开始位置和结束位置。 
3. 差错控制：用于使接收方确定收到的数据就是由发送方发送的数据。 
4. 透明传输：不论数据是什么样的比特组合，都应当能够在链路上进行传输。 

## ✏ 2、帧

帧（frame）是数据链路层的传送单位，在 HDLC 协议中，一个帧的格式如下：

| 标志 | 地址 | 控制 | 信息 | 帧校验序列 | 标志 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| F 01111110 | A 8位 | C 8位 | Info N位（可变） | FCS 16位 | F 011111110 |

> 1、问：什么是帧定界？ 
>
> 答：当两个主机之间互相传送消息时，网络层的分组必须将封装成帧，并以帧的格式进行传送。将一段数据的前后分别添加首部和尾部，就够成了帧。首部和尾部中含有很多控制信息，这些信息的重要作用之一就是确定帧的界限，这就是帧定界。 例如，在 HDLC 协议中，帧格式使用标志 F\(01111110\) 来标识帧的开始和结束。
>
> 2、问：为什么组帧时及要求加首部，也要加尾部？而报文切割成分组只加首部？ 
>
> 答：因为在网络中是以帧为最小单位进行传输的，所以接收端要正确地收到帧，必须要清楚该帧再一串比特流中是从哪里开始再哪里结束（因为接收端接收到的时一串比特流，没有首部和尾部不能正确的区分帧）。而分组（也称为 IP数据报）仅仅是包含在帧的数据部分，所以不需要加尾部来定界。

### 🔨 2.1、透明传输

透明表示一个实际存在的事物看起来好像不存在一样。上表中 **地址到帧校验序列之间为 透明传输区间。**帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。如：在 01111110 中拥有 6 个连续的 ‘1’，只要数据帧检测到有 5 个连续的 ‘1’，便马上再其后面插入 ‘0’，而在接收方对该过程实施逆操作，即每次收到 5 个连续的 ‘1’，自动删除后面紧紧跟随的 ‘0’，以恢复数据。这样的方法又称为零比特填充法。

### 🔨 2.2、组帧

为什么要组帧？直接传送比特流不就可以了？还免去了帧同步、帧定界、透明传输等问题。但是反过来思考，万一传送的比特流出错了怎么办？那就得重新传输全部的比特流，组帧的优点就在于，如果传输出现了错误，只需要重新发送错误的帧即可，这相对于增加帧同步、帧定界、透明传输问题是值得的。组帧不能随意组合，需要让接收方看懂才行，这就需要依据一定的规则将网络层递交下来的分组组装成帧。

四种组帧方法：字符计数法、字节填充的首尾界符法、**比特填充的首尾标志法**、物理编码违例法。

## ✏ 3、差错控制

### 🔨 3.1、检错编码

检错编码：通过一定的编码和解码，能够在接收端解码时检查出传输的错误，但不能纠正错误。常见的检错编码具有有奇偶校验码和循环冗余校验码\(`CRC)`。

#### 🎤 3.1.1、奇偶校验码

在信息码后面加一位校验码，分奇校验和偶校验。

1. 奇校验：添加一位校验码之后，保持整个码字里面的 1 的个数是奇数。接收端收到数据之后就校验数据里面 1 的个数，如果检查到奇数个 1 ，那么认为传输过程中没有出错，如果检查到偶数个 1 ，则说明传输过程中数据发生了改变，要求重发。
2. 偶校验：添加一位校验码之后，保持整个码字里面的 1 的个数是偶数。接收端收到数据之后就校验数据里面 1 的个数，如果检查到偶数个 1 ，那么认为传输过程中没有出错，如果检查到奇数个 1 ，则说明传输过程中数据发生了改变，要求重发。 当数据中有一位发生变化时，奇偶校验码能够检测出来，但是不知道是哪一位发生了错误。如果数据中有两位数据发生了编码，那么奇偶校验码检测不到数据出错。所以它的检错能力是有限的。

奇偶校验码在实际使用中又分为垂直奇偶校验、水平奇偶校验与水平垂直奇偶校验。上述内容属于水平奇偶校验。

#### 🎤 3.1.2、循环冗余校验码

适当选择多项式  $$G(x)$$ ，在计算机二进制信息 $$M(x)$$ 的长度确定时，余数与 `CRC` 码出错位的对应关系是不变的，可以使用余数作为判断出错位置的依据而纠正编码。检错方式：将受到的 `CRC` 码与 $$G(x)$$  相除，如果余数为 0 ，那么数据正确。如果余数不为 0 ，那么可以判断出错的位置。

举个例子：试计算 `10110010000/11001`

计算技巧：在除法过程中，进行异或运算，无视进位；上商的规则是看余数的首尾，如果为 1，则上 1，如果为 0 ，则上 0；当部分余数的位数小于除数的位数时，该余数便是最后的余数。可以得到 10110010000/11001 余数为 1010.

**`CRC`码进行检错的重要特征**

1. **具有 r 检测位的多项式嫩能够检测出所有小于或者等于 r 的突发错误**
2. **长度大于 r + 1 的错误逃脱的概率为** $$\frac{1}{2^r}$$ **.**

  
注意：1. 循环冗余码仅能做到无差错接受。 2. `CRC` 具有纠错功能。但是在计算机网络中一般发现错误直接重传，因此在默认情况下，`CRC`为检错码而不是纠错码。

### 🔨 3.2、纠错编码

纠错编码：在接受端不仅能够检查出错误，而且还能够就成检查出来的错误。常见的纠错码是海明码。

#### 🎤 3.2.1、海明码

