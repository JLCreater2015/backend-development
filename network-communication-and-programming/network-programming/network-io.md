# 网络IO模型

## ✏ 1、网络IO

网络IO的本质就是socket流的读取，socket在`linux`系统被抽象为流，IO可以理解为对流的操作，在网络通信中，对数据进行读写的过程中，数据在发送端和接收端的相应设备上进行如下传递：

> 发送端发送缓冲区-&gt;发送端驱动程序-&gt;发送端网卡-&gt;接收端网卡-&gt;接收端驱动程序-&gt;接收端接收缓冲区

对数据进行写入时，应用程序调用`write/sendto`等相关系统调用将数据发送到接收端的接收缓冲区；在读取数据时，应用程序调用`read/recvfrom`等相关系统调用将数据从接收缓冲区搬运到用户区。

通常一次IO读操作会涉及到两个对象和两个阶段。

两个对象分别是：

* 用户进程（线程）Process（Thread） 
* 内核对象 Kernel 

 以数据的读取为例，在调用read等系统调用时，会经历以下两个阶段：

* 等待流数据准备（wating for the data to be ready）; 
* 从内核向进程复制数据（copying the data from the kernel to the process）; 

对于socket流而已：

* 第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。 
* 第二步把数据从内核缓冲区复制到应用进程缓冲区。 

Richard Stevens的经典书籍`UNP`，书中给出5种IO模型：

* blocking IO - 阻塞IO 
* non-blocking IO - 非阻塞IO 
* IO multiplexing - IO多路复用 
* signal driven IO - 信号驱动IO 
* asynchronous IO - 异步IO 

## ✏ 2、五种IO模型

### 🖋 2.1、阻塞IO

阻塞式IO在进行数据读取时，如果内核中没有数据（发送端可能还没有发送数据或者发送的数据还没有达到），此时内核就开始等待数据，同时用户进程也进入阻塞状态，整个进程就会被挂起等待，不能做其他的事情。当有数据到达内核时，内核等待结束，将数据从内核拷贝到用户区，用户进程结束阻塞，从挂起状态转为运行状态。

