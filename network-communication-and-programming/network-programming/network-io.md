# 网络IO模型

## ✏ 1、网络IO

网络IO的本质就是socket流的读取，socket在`linux`系统被抽象为流，IO可以理解为对流的操作，在网络通信中，对数据进行读写的过程中，数据在发送端和接收端的相应设备上进行如下传递：

> 发送端发送缓冲区-&gt;发送端驱动程序-&gt;发送端网卡-&gt;接收端网卡-&gt;接收端驱动程序-&gt;接收端接收缓冲区

对数据进行写入时，应用程序调用`write/sendto`等相关系统调用将数据发送到接收端的接收缓冲区；在读取数据时，应用程序调用`read/recvfrom`等相关系统调用将数据从接收缓冲区搬运到用户区。

通常一次IO读操作会涉及到两个对象和两个阶段。

两个对象分别是：

* 用户进程（线程）Process（Thread） 
* 内核对象 Kernel 

 以数据的读取为例，在调用read等系统调用时，会经历以下两个阶段：

* 等待流数据准备（wating for the data to be ready）; 
* 从内核向进程复制数据（copying the data from the kernel to the process）; 

对于socket流而已：

* 第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。 
* 第二步把数据从内核缓冲区复制到应用进程缓冲区。 

Richard Stevens的经典书籍`UNP`，书中给出5种IO模型：

* blocking IO - 阻塞IO 
* non-blocking IO - 非阻塞IO 
* IO multiplexing - IO多路复用 
* signal driven IO - 信号驱动IO 
* asynchronous IO - 异步IO 

## ✏ 2、五种IO模型

### 🖋 2.1、阻塞IO

阻塞式IO在进行数据读取时，如果内核中没有数据（发送端可能还没有发送数据或者发送的数据还没有到达），此时内核就开始等待数据，同时用户进程也进入阻塞状态，整个进程就会被挂起等待，不能做其他的事情。当有数据到达内核时，内核等待结束，将数据从内核拷贝到用户区，用户进程结束阻塞，从挂起状态转为运行状态。

 **所以，阻塞式IO在进行数据读取时，上述两个阶段都会阻塞（内核等待数据，用户进程阻塞）。**

在Linux中，默认所有的socket都是阻塞式的。阻塞式接口是指当进行系统调用时，如果数据没有准备好，该应用进程就会被挂起，系统调用不会返回，直到有数据到达或者调用出错时，系统调用才会返回，进程才会结束阻塞状态。

实际上几乎所有的IO接口（包含socket）都是阻塞的。如果在一个网络编程中，一个服务器需要处理多客户端的情形，如果是单进程的服务器。在与一个客户端连接建立之后，服务器就会使用read等系统调用对客户端进行数据读取来处理请求。当该客户端没有发送数据或者发送的数据还没有达到时，服务器就会进入阻塞状态，此时整个服务器进程就会挂起。当其他客户端连接请求达到时，服务器由于处于挂起状态爱，什么也不能做，所以也不能对其他客户端进行处理。因此，上述所说的单进程的阻塞式IO的服务器只能处理一个客户端的情况，所以这样的服务器没有任何的实用性。 

所以，可以创建多进程或多线程（多个执行流）来处理多客户端的情形。如果在对一个客户端进行读取时导致一个进程被挂起，可以创建其他的进程来处理其他客户端的请求。但是多进程和多线程的创建也要浪费一定的资源，也有一定的局限性，所以一般适用于中小型应用场景。

### 🖋 2.2、非阻塞IO





