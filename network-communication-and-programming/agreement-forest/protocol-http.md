---
description: 详解HTTP协议。
---

# HTTP

HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），是一个属于应用层的面向对象的协议，**默认端口号是 80**，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 它于1990年被提出，由于其简洁性、快速性等特点，被广泛应用，并且经过不断的完善和发展，功能也越来越强大，目前已经发展到`HTTP/2`版本。**HTTP协议工作于客户端-服务端架构之上**，浏览器作为HTTP客户端通过URL向HTTP服务端即Web服务器发送所有请求，Web服务器根据接收到的请求后，向客户端发送响应信息。

## ✏ URL

URL，全称是UniformResourceLocator，中文叫统一资源定位符，是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：

```text
http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name
```

一个完整的URL包括以下几部分：

1. 协议部分：该URL的协议部分为`“http:”`，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在`“http:”`后面的`“//”`为分隔符。
2. 域名部分：该URL的域名部分为`“www.aspxfans.com”`。一个URL中，也可以使用IP地址作为域名使用。
3. 端口部分：跟在域名后面的是端口，域名和端口之间使用`“:”`作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口。
4. 虚拟目录部分：从域名后的第一个`“/”`开始到最后一个`“/”`为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是`“/news/”`。
5. 文件名部分：从域名后的最后一个`“/”`开始到`“?”`为止，是文件名部分，如果没有`“?”`，则是从域名后的最后一个`“/”`开始到`“#”`为止，是文件部分，如果没有`“?”`和`“#”`，那么从域名后的最后一个`“/”`开始到结束，都是文件名部分。本例中的文件名是`“index.asp”`。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。
6. 锚部分：从`“#”`开始到最后，都是锚部分。本例中的锚部分是`“name”`。锚部分也不是一个URL必须的部分。
7. 参数部分：从`“?”`开始到`“#”`为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为`“boardID=5&ID=24618&page=1”`。参数可以允许有多个参数，参数与参数之间用`“&”`作为分隔符。

### 🖌 URL与URI

HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。

**URI，uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。**

Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的，URI一般由三部组成：①访问资源的命名机制；②存放资源的主机名；③资源自身的名称，由路径表示，着重强调于资源。

**URL，uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。**

URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等，URL一般由三部组成： ①协议\(或称为服务方式\) ；②存有该资源的主机IP地址\(有时也包括端口号\) ；③主机资源的具体地址，如目录和文件名等。

**URN，uniform resource name，统一资源命名，是通过名字来标识资源，它命名资源但不指定如何定位资源，比如`mailto:java-net@java.sun.com`。**

URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。在Java中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则，URI类不包含任何访问资源的方法，它唯一的作用就是解析。而URL实例则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的，并且一个URL类的实例可以打开一个到达资源的流。

## ✏ Http的特点

1. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
2. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由`Content-Type`加以标记。
3. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
4. 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
5. 支持B/S及C/S模式。

## ✏ 版本历史

### 🖌 1、HTTP/0.9

最早版本发布于`1991`年，功能极其简单，不涉及数据包的传输，默认使用80端口，只有一个`GET`请求方法，且服务器只能响应`HTML`格式的字符串，服务器响应后即关闭连接。

### 🖌 2、HTTP/1.0

`1996`年`5`月，`HTTP/1.0`发布，引入了`POST`和`HEAD`命令，大大增强了交互功能，任何格式的内容都可以发送，为互联网的大发展奠定了基础；同时，除了数据部分，每次通信还要求包含头信息（`HTTP header`），来描述一些`meta`数据。

新增功能还包括：状态码（`status code`）、多字符集支持、多部分发送（`multi-part type`）、权限（`authorization`）、缓存（`cache`）、内容编码（`content encoding`）等。

> **缺点：**`HTTP/1.0`版的主要缺点是，由于`TCP`的每次连接都需要客户端和服务端进行`3`次握手，但是连接成功后只能发送一次请求，然后连接就断开了，如果需要多次请求，这样效率就很低。但是，为了解决多次请求效率低下的问题，有一个非标准的`connection`字段暂时解决了该问题。

```text
Connection: keep-alive
```

> 这样就可以复用`TCP`连接，直到客户端或者服务端主动关闭连接。但是这不是标志字段，不同的实现可能行为不一致，所以是一种暂时的解决方案。

### 🖌 3、HTTP/1.1

 `1997`年`1`月，`HTTP/1.1`版本发布，它进一步完善了`HTTP`协议，一直到今天还在使用，是最流行的版本；`HTTP/1.1`新增了许多特性：

#### 1.持久连接

`HTTP/1.1`默认`TCP`连接不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。客户端可以在最后一个请求时，主动发送`Connection: close`，明确要求服务器关闭`TCP`连接，或者不发送，那么客户端和服务器发现对方一段时间没有活动，就会主动关闭连接。目前，对于同一个域名，大多数浏览器允许同时建立`6`个持久连接。

#### 2.管道机制

`HTTP/1.1`引入了管道机制（`pipelining`），即在同一个`TCP`连接里面，客户端可以同时发送多个请求，这样只是改进了客户端`HTTP`协议请求的效率，服务器还是按照请求的先后顺序来响应。

#### 3.Content-Length

`Content-Length`字段显示本次响应的数据长度，如果数据被压缩，则是压缩后的长度。在`Connection: keep-alive`条件下，`Content-Length`是必须的；反之，和`HTTP/1.0`一样，`Content-Length`不是必须的。

#### 4.分块传输编码

使用`Content-Lenght`字段的前提条件是，服务器发送响应之前，必须知道响应的数据长度。但是，对于一些耗时的动态操作来说，服务器要等到所有操作完成后，才能发送数据，效率不高。因此，`HTTP`采用了“流模式（`stream`）”，即“分块传输编码”（`chunked transfer encoding`）方式，表明响应的数据长度未定，这样就可以产生一块数据，就发送一块数据，提高服务器的响应效率。只要请求或响应的头信息里有`Transfer-Encoding`字段，就表明响应将由数量未定的数据组成。每个非空的数据块之前，都会有一个`16`进制的数值，表示这个块的长度；最后一个是大小为`0`的块，表示本次响应数据发送完了。

```http
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0
```

#### 5.其它特性

新增了许多的请求方式：`PUT`、`PATCH`、`OPTIONS`、`DELETE`、`TRACE`，还增加了`Host`字段，用来指定服务器的域名，就可以把同一请求发送给不同的网站，为虚拟主机的发展奠定了基础。

> 缺点：虽然`HTTP/1.1`版允许复用`TCP`连接，但是同一个`TCP`连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着，这称为"队头堵塞"（`Head-of-line blocking`）。
>
> 为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入`CSS`代码、域名分片（`domain sharding`）等等。如果`HTTP`协议设计得更好一些，这些额外的工作是可以避免的。

### 🖌 4、HTTP/2

2015年，HTTP/2发布，主要解决了`HTTP1.1`的效率不高的问题，新增了二进制协议、多工、数据流、头信息压缩等等功能，具体介绍如下：

#### 1.二进制协议

`HTTP/2`是一个彻底的二进制协议，头信息和数据都是二进制，统称为**帧**（`frame`）：头信息帧和数据帧。二进制的优势是：可以定义额外的帧，以适应未来更高级的应用。

#### 2.多工

`HTTP/2`复用`TCP`连接，客户端和服务器都可以同时发送多个请求或响应，不用按照顺序一一对应，避免了**对头堵塞**，实现了双向的、实时的通信。

#### 3.数据流

`HTTP/2`定义每个请求或响应的所有数据为一个数据流（`stream`），每个数据流都有一个唯一的编号，数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。协议规定：客户端发出的数据流的ID位奇数，服务器发出的数据流ID为偶数。

另外，数据流发送过程中，客户端和服务器都可以随时发送信号而不用关闭`TCP`连接，以便其它请求使用。但是`HTTP1.1`就不行，它取消请求的方式必须的关闭连接。`HTTP/2`还指定了数据流的优先级，优先级越高，服务器就优先处理。

#### 4.头信息压缩

`HTTP` 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如`Cookie`和`User Agent`，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

`HTTP/2` 对这一点做了优化，引入了头信息压缩机制（`header compression`）。一方面，头信息使用`gzip`或`compress`压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

#### 5.服务器推送

`HTTP/2`允许服务器主动向客户端发送资源，主要是服务器经过预测，把一些客户端可能请求的资源主动发送给客户端，提高用户体验。

## ✏ 请求消息Request

HTTP的请求报文包括：**请求行\(request line\)**、**请求头部\(header\)**、**空行** 和 **请求数据** 四个部分组成。

![](../../.gitbook/assets/23%20%281%29.png)

 抓包的`request`结构如下：

```http
GET /mix/76.html?name=kelvin&password=123456 HTTP/1.1
Host: www.fishbay.cn
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
```

**1.请求行：**`GET`为请求类型，`/mix/76.html?name=kelvin&password=123456`为要访问的资源，`HTTP/1.1`是协议版本

**2.请求头部：**从第二行起为请求头部，`Host`指出请求的目的地（主机域名）；`User-Agent`是客户端的信息，它是检测浏览器类型的重要信息，由浏览器定义，并且在每个请求中自动发送。

**3.空行：**请求头后面必须有一个空行

**4.请求数据：**请求的数据也叫请求体，可以添加任意的其它数据。这个例子的请求体为空。

### 🖌 1、请求头

**常用标准请求头字段有：**

1. **Accept：**指浏览器或其他客户可以接爱的`MIME`文件格式。
2. **Accept-Encoding：**指出浏览器可以接受的编码方式。
3. **Accept-Langeuage：**指出浏览器可以接受的语言种类，如`en`或`en-us`，指英语。
4. **Connection：**用来告诉服务器是否可以维持固定的HTTP连接。
5. **Cookie：**浏览器用这个属性向服务器发送`Cookie`。
6. **Host：**对应网址URL中的Web名称和端口号。
7. **User-Agent：**客户浏览器名称。
   * **兼容性问题**
8. **Referer：**表明产生请求的网页URL。
   * 防盗链
   * 统计工作
9. **Content-Type：**用来表明`request`的内容类型（适用POST和PUT请求）。 
10. **Accept-Charset：**指出浏览器可以接受的字符编码。英文浏览器的默认值是`ISO-8859-1`。
11. **If-Modified-Since：**如：`Tue, 11 Jul 2000 18:23:51 GMT`，告诉服务器，缓冲中有这个资源文件，并带上文件的时间。
12. **Date：**浏览器发送该http请求的时间。

更多字段[https://www.cnblogs.com/widget90/p/7650890.html](https://www.cnblogs.com/widget90/p/7650890.html)。

### 🖌 2、请求方法

`HTTP1.0`定义了三种请求方法： `GET, POST` 和 `HEAD`方法。

`HTTP1.1`新增了五种请求方法：`OPTIONS, PUT, DELETE, TRACE` 和 `CONNECT` 方法。

| 方法 | 描述 |
| :---: | :--- |
| GET | 请求指定的页面信息，并返回实体主体。 |
| HEAD | 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 |
| POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 |
| PUT | 从客户端向服务器传送的数据取代指定的文档的内容。 |
| DELETE | 请求服务器删除指定的页面。 |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 |
| OPTIONS | 允许客户端查看服务器的性能。 |
| TRACE | 回显服务器收到的请求，主要用于测试或诊断。 |

### 🖌 3、GET和POST

## ✏ 响应消息Response

一般情况下，服务器收到客户端的请求后，就会有一个`HTTP`的响应消息，HTTP响应也由`4`部分组成，分别是：**状态行**、**响应头**、**空行** 和 **响应体**。

![](../../.gitbook/assets/22%20%281%29.png)

抓包的`response`结构如下：

```http
HTTP/1.1 200 OK
Server: nginx
Date: Mon, 20 Feb 2017 09:13:59 GMT
Content-Type: text/plain;charset=UTF-8
Vary: Accept-Encoding
Cache-Control: no-store
Pragrma: no-cache
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Cache-Control: no-cache
Content-Encoding: gzip
Transfer-Encoding: chunked
Proxy-Connection: Keep-alive

{"code":200,"notice":0,"follow":0,"forward":0,"msg":0,"comment":0,"pushMsg":null,"friend":{"snsCount":0,"count":0,"celebrityCount":0},"lastPrivateMsg":null,"event":0,"newProgramCount":0,"createDJRadioCount":0,"newTheme":true}
```

**1.状态行：**状态行由协议版本号、状态码、状态消息组成。

**2.响应头：**响应头是客户端可以使用的一些信息，如：`Date`（生成响应的日期）、`Content-Type`（MIME类型及编码格式）、`Connection`（默认是长连接）等等。

**3.空行：**响应头和响应体之间必须有一个空行。

**4.响应体：**响应正文，本例中是键值对信息。

### 🖌 1、响应头

**常用标准响应头字段有：**

1. **Status：**设置HTTP响应状态。
2. **Server：**服务器名称。如：`Server: Apache/2.4.1 (Unix)`。
3. **Content-Type：**设置响应体的MIME类型。 
4. **Content-Encoding：**设置数据使用的编码类型。发送的数据还可以被压缩后再发送，该字段说明了数据压缩的方法。如：`gzip`、`compress`、`deflate`。客户端还可以在请求时，用`Accept-Encoding`字段说明自己可以接受哪些压缩方法。`Accept-Encoding: gzip, deflate`。
5. **Content-Language：**为封闭内容设置自然语言或者目标用户语言。
6. **Content-Length：**响应体的字节长度。
7. **Connection：**`close/Keep-Alive`，设置当前连接和hop-by-hop协议请求字段列表的控制选项。

### 🖌 2、数据类型

`1.0`版规定，头信息必须是ASCII码，后面的数据可以是任何格式，因此，服务器在响应的时候，也要告诉客户端，数据是什么格式。`Content-Type`字段的常用值：`text/plain`、`text/html`、`text/css`、`image/jpeg`、`image/png`、`image/svg+xml`、`audio/mp4`、`video/mp4`、`application/javascript`、`application/pdf`、`application/zip`、`application/atom+xml`。另外，这些数值统称为`MIME type`，每个值包括一级类型和二级类型，之间用斜杠分隔，用户也可以自定义该类型，还可以在尾部使用分号，添加参数：`Content-Type: text/html; charset=utf-8`表示发送的是网页，并且编码是的UTF-8格式，`Accept: */*`  表示客户端可以接受任何格式的数据。

更多数据类型[https://www.runoob.com/http/http-content-type.html](https://www.runoob.com/http/http-content-type.html)。

### 🖌 3、状态码

#### 🎇 3.1、HTTP状态码分类

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：

| HTTP状态码分类 |  |
| :--- | :--- |
| 分类 | 分类描述 |
| 1\*\* | 信息，服务器收到请求，需要请求者继续执行操作 |
| 2\*\* | 成功，操作被成功接收并处理 |
| 3\*\* | 重定向，需要进一步的操作以完成请求 |
| 4\*\* | 客户端错误，请求包含语法错误或无法完成请求 |
| 5\*\* | 服务器错误，服务器在处理请求的过程中发生了错误 |

#### 🎇 3.2、常见的状态码

1. 101 Switching Protocols      //切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
2. 200 OK                                    //客户端请求成功
3. 204 No Content                     //无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
4. 301 Moved Permanently     //永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
5. 302 Moved Temporarily      //请求临时重定向
6. 304 Not Modified                 //文件未修改，可以直接使用缓存的文件
7. 400 Bad Request                  //客户端请求有语法错误，不能被服务器所理解
8. 401 Unauthorized                 //请求未经授权，这个状态代码必须和`WWW-Authenticate`报头域一起使用
9. 403 Forbidden                       //服务器收到请求，但是拒绝提供服务
10. 404 Not Found                      //请求资源不存在，eg：输入了错误的URL
11. 500 Internal Server Error     //服务器发生不可预期的错误
12. 503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常

更多状态码[http://www.runoob.com/http/http-status-codes.html](http://www.runoob.com/http/http-status-codes.html)。

## ✏ 工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。以下是 HTTP 请求/响应的步骤：

**1、客户端连接到Web服务器：**一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。

**2、发送HTTP请求：**通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

**3、服务器接受请求并返回HTTP响应：**Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

**4、释放连接TCP连接：**若 connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若 connection 模式为keep-alive，则该连接会保持一段时间，在该时间内可以继续接收请求。

**5、客户端浏览器解析HTML内容：**客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

> 在浏览器地址栏键入URL，按下回车之后会经历以下流程：
>
> 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；
>
> 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接；
>
> 3、浏览器发出读取文件\(URL 中域名后面部分对应的文件\)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；
>
> 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；
>
> 5、释放 TCP连接；
>
> 6、浏览器将该 html 文本解析并显示内容。

